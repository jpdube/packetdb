use crate::ipv4_address::IPv4;
use crate::ipv6_address::IPv6;
use crate::layer::Layer;
use crate::pfield::{Field, FieldType};
use crate::print_hex::print_hex;
use ::chrono::prelude::*;
use byteorder::{BigEndian, ByteOrder};
use std::str;
use std::{fmt, usize};

pub const DNS_TYPE_A: u16 = 1;
pub const DNS_TYPE_AAAA: u16 = 28;
pub const DNS_TYPE_CNAME: u16 = 5;
pub const DNS_TYPE_SOA: u16 = 6;
pub const DNS_TYPE_PTR: u16 = 12;
pub const DNS_TYPE_MX: u16 = 15;
pub const DNS_TYPE_TXT: u16 = 16;
pub const DNS_TYPE_SRV: u16 = 33;
pub const DNS_TYPE_DNS_KEY: u16 = 0x30;
pub const DNS_TYPE_RRSIG: u16 = 0x2e;

pub const DNS_CLASS_IN: u16 = 1;

const INDEX_TYPE_A: u16 = 0;
const INDEX_TYPE_AAAA: u16 = 2;
const INDEX_TYPE_CNAME: u16 = 4;
const INDEX_TYPE_SOA: u16 = 8;
const INDEX_TYPE_PTR: u16 = 16;
const INDEX_TYPE_MX: u16 = 32;
const INDEX_TYPE_TXT: u16 = 64;
const INDEX_TYPE_SRV: u16 = 128;
const INDEX_TYPE_RRSIG: u16 = 256;
const INDEX_TYPE_DNSKEY: u16 = 512;

fn rtype_to_str(rtype: u16) -> String {
    match rtype {
        DNS_TYPE_A => String::from("A (1) IPV4"),
        DNS_TYPE_AAAA => String::from("AAAA (28) IPV6"),
        DNS_TYPE_CNAME => String::from("CNAME (5)"),
        DNS_TYPE_MX => String::from("MX (15)"),
        DNS_TYPE_PTR => String::from("PTR (12)"),
        DNS_TYPE_TXT => String::from("TXT (16)"),
        DNS_TYPE_SOA => String::from("SOA (6)"),
        DNS_TYPE_SRV => String::from("SRV (33)"),
        _ => String::from("NONE"),
    }
}

fn class_to_str(rtype: u16) -> String {
    match rtype {
        DNS_CLASS_IN => String::from("IN"),
        _ => String::from("NONE"),
    }
}

#[derive(Debug, Default, Clone)]
pub struct Srv {
    service: String,
    protocol: String,
    priority: u16,
    weight: u16,
    port: u16,
    target: String,
}

impl fmt::Display for Srv {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Service: {}, Protocol: {}, Priority: {},  Weight: {}, Port: {}, Target: {}",
            self.service, self.protocol, self.priority, self.weight, self.port, self.target,
        )
    }
}

#[derive(Debug, Default, Clone)]
struct RRsig {
    type_covered: u16,
    algorithm: u8,
    labels: u8,
    orig_ttl: u32,
    sig_expiration: u32,
    sig_inception: u32,
    key_tag: u16,
    signer_name: String,
    signature: Vec<u8>,
}

impl fmt::Display for RRsig {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Type covered: {}, Algorithm: {:0x}, Labels: {}, Origin TTL: {},  Signature expiration: {} - {:0x}, Signature inception: {} - {:0x}, Key tag: {:0x}, Signature name: {}, Signature: {:x?}",
            rtype_to_str(self.type_covered),
            self.algorithm,
            self.labels,
            self.orig_ttl,
            timestamp_str(&self.sig_expiration),
            self.sig_expiration,
            timestamp_str(&self.sig_inception),
            self.sig_inception,
            self.key_tag,
            self.signer_name,
            self.signature
        )
    }
}

#[derive(Debug, Clone, Default)]
struct DnsKey {
    flags: u16,
    protocol: u8,
    algorithm: u8,
    public_key: Vec<u8>,
}

impl<'a> fmt::Display for DnsKey {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Flags: {}, Protocol: {:0x}, Algorithm: {}, Public key: {:x?}",
            self.flags, self.protocol, self.algorithm, self.public_key
        )
    }
}

fn timestamp_str(ts: &u32) -> String {
    let naive = Utc.timestamp_opt(*ts as i64, 0).unwrap();
    let timestamp = naive.format("%Y-%m-%d %H:%M:%S");
    format!("{}", timestamp)
}

// TODO: Implement DNS additional records
// #[derive(Debug)]
// pub struct AdditionalRec {
//     name: String,
//     otype: u16,
//     udp_size: u16,
//     higher_bit_extended: u8,
//     edns_version: u8,
//     z_value: u16,
//     data_length: u16,
// }

#[derive(Debug, Default, Clone)]
pub struct SOARecord {
    name: String,
    auth_mailbox: String,
    serial_no: u32,
    refresh_interval: u32,
    retry_interval: u32,
    expire_limit: u32,
    min_ttl: u32,
}

impl fmt::Display for SOARecord {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Name: {}, Auth mailbox: {}, SerialNo: {:x}, Refresh interval: {},  Retry interval: {}, Expire limit: {}, Min ttl: {:x}",
            self.name,
            self.auth_mailbox,
            self.serial_no,
            self.refresh_interval,
            self.retry_interval,
            self.expire_limit,
            self.min_ttl,
        )
    }
}
#[derive(Debug, Default, Clone)]
pub struct Answer {
    name: String,
    rtype: u16,
    class: u16,
    ttl: u32,
    rdlength: usize,
    cname: String,
    ipv4_addr: u32,
    ipv6_addr: u128,
    txt: String,
    asize: usize,
    srv: Srv,
    rrsig: Option<RRsig>,
    soa: Option<SOARecord>,
    dns_key: Option<DnsKey>,
}

impl fmt::Display for Answer {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Label: {}, Type: {}, Class: {}, TTL: {},  Data length: {}, CNAME: {}, TXT: {}, IPv4 Address: {}, IPv6 Address: {}, Nbr bytes: {}, Srv: {}, Dns key: {}",
            self.name,
            rtype_to_str(self.rtype),
            class_to_str(self.class),
            self.ttl,
            self.rdlength,
            self.cname,
            self.txt,
            IPv4::new(self.ipv4_addr, 32).to_string(),
            IPv6::new(self.ipv6_addr, 128).to_string(),
            self.asize,
            self.srv,
            self.dns_key.clone().unwrap(),
        )
    }
}

impl<'a> Answer {
    fn get_txt(
        &self,
        raw_data: &'a [u8],
        offset: usize,
        id: u16,
    ) -> Result<(String, usize), String> {
        let mut index = offset;

        let txt_len = raw_data[index] as usize;
        index += 1;

        match str::from_utf8(&raw_data[index..index + txt_len]) {
            Ok(txt_value) => {
                let txt = String::from(txt_value);
                return Ok((txt.clone(), index + txt.len()));
            }
            Err(msg) => {
                return Err(format!(
                    "Error reading TXT field: {} ID: {:x}, Length: {}:{:x}",
                    msg, id, txt_len, txt_len
                ));
            }
        }
    }

    pub fn decode(&mut self, raw_data: &'a [u8], offset: usize, id: u16) {
        let mut index: usize = offset;
        let start_pos;
        let mut label_size: usize;

        (self.name, label_size) = get_name(raw_data, offset, id);
        index += label_size;

        self.rtype = BigEndian::read_u16(&raw_data[index..index + 2]);
        index += 2;
        self.class = BigEndian::read_u16(&raw_data[index..index + 2]);
        index += 2;
        self.ttl = BigEndian::read_u32(&raw_data[index..index + 4]);
        index += 4;
        self.rdlength = BigEndian::read_u16(&raw_data[index..index + 2]) as usize;
        index += 2;

        match self.rtype {
            DNS_TYPE_CNAME => {
                (self.cname, _) = get_name(&raw_data, index, id);
                self.asize = index + self.rdlength;
            }
            DNS_TYPE_A => {
                self.ipv4_addr = BigEndian::read_u32(&raw_data[index..index + 4]);
                self.asize = index + 4;
            }
            DNS_TYPE_AAAA => {
                self.ipv6_addr = BigEndian::read_u128(&raw_data[index..index + 16]);
                self.asize = index + 16;
            }
            DNS_TYPE_TXT => {
                if let Ok((txt, size)) = self.get_txt(raw_data, index, id) {
                    self.txt = txt;
                    self.asize = size;
                }
            }

            DNS_TYPE_SRV => {
                let mut srv_rec = Srv::default();

                let fields = self.name.split(".").collect::<Vec<&str>>();

                if fields.len() > 2 {
                    srv_rec.service = fields[0].to_string();
                    srv_rec.protocol = fields[1].to_string();
                } else {
                    srv_rec.service = "undefined".to_string();
                    srv_rec.protocol = "undefined".to_string();
                }

                srv_rec.priority = BigEndian::read_u16(&raw_data[index..index + 2]);
                index += 2;

                srv_rec.weight = BigEndian::read_u16(&raw_data[index..index + 2]);
                index += 2;

                srv_rec.port = BigEndian::read_u16(&raw_data[index..index + 2]);
                index += 2;

                (srv_rec.target, label_size) = get_name(&raw_data, index, id);

                self.asize = index + label_size;
                self.srv = srv_rec;
            }
            DNS_TYPE_DNS_KEY => {
                let mut dns_key = DnsKey::default();

                dns_key.flags = BigEndian::read_u16(&raw_data[index..index + 2]);
                index += 2;

                dns_key.protocol = raw_data[index];
                index += 1;

                dns_key.algorithm = raw_data[index];
                index += 1;

                dns_key.public_key = raw_data[index..index + self.rdlength - 4].to_vec();

                self.asize = index + dns_key.public_key.len();
                self.dns_key = Some(dns_key);
            }
            DNS_TYPE_RRSIG => {
                let mut rrsig = RRsig::default();

                start_pos = index;
                self.asize = index + self.rdlength;

                rrsig.type_covered = BigEndian::read_u16(&raw_data[index..index + 2]);
                index += 2;

                rrsig.algorithm = raw_data[index];
                index += 1;

                rrsig.labels = raw_data[index];
                index += 1;

                rrsig.orig_ttl = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                rrsig.sig_expiration = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                rrsig.sig_inception = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                rrsig.key_tag = BigEndian::read_u16(&raw_data[index..index + 2]);
                index += 2;

                (rrsig.signer_name, label_size) = get_name(&raw_data, index, id);
                index += label_size;

                let sig_len = index - start_pos;
                rrsig.signature = raw_data[index..index + (self.rdlength - sig_len)].to_vec();

                self.rrsig = Some(rrsig);
            }
            DNS_TYPE_SOA => {
                let mut soa = SOARecord::default();

                (soa.name, label_size) = get_name(&raw_data, index, id);
                index += label_size;

                (soa.auth_mailbox, label_size) = get_name(&raw_data, index, id);
                index += label_size;

                soa.serial_no = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                soa.refresh_interval = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                soa.retry_interval = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                soa.expire_limit = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                soa.min_ttl = BigEndian::read_u32(&raw_data[index..index + 4]);
                index += 4;

                self.asize = index;
                self.soa = Some(soa);
            }

            _ => {}
        }
    }
}

#[derive(Debug, Default, Clone)]
pub struct Query {
    name: String,
    rtype: u16,
    class: u16,
    qsize: usize,
}

impl fmt::Display for Query {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Label: {}, Type: {}, Class: {} Size: {}",
            self.name,
            rtype_to_str(self.rtype),
            class_to_str(self.class),
            self.qsize,
        )
    }
}

impl<'a> Query {
    pub fn decode(&mut self, raw_data: &'a [u8], offset: usize, id: u16) {
        let label_size: usize;

        (self.name, label_size) = get_name(raw_data, offset, id);

        let mut index = offset + label_size;
        self.rtype = BigEndian::read_u16(&raw_data[index..index + 2]);
        index += 2;
        self.class = BigEndian::read_u16(&raw_data[index..index + 2]);

        if self.name == "<Root>" {
            self.qsize = 1 + 2 + 2;
        } else {
            self.qsize = self.name.len() + 2 + 2 + 2;
        }
    }
}

#[derive(Debug, Default, Clone)]
pub struct Dns<'a> {
    raw_packet: &'a [u8],
    offset: usize,
    query_list: Vec<Query>,
    answer_list: Vec<Answer>,
    type_index: u16,
}

impl<'a> Dns<'a> {
    pub fn new(packet: &'a [u8]) -> Self {
        let mut my_self = Self {
            raw_packet: packet,
            offset: 12,
            query_list: Vec::new(),
            answer_list: Vec::new(),
            type_index: 0,
        };

        my_self.decode();

        my_self
    }

    fn set_index(&mut self, rtype: u16) {
        match rtype {
            DNS_TYPE_A => self.type_index = self.type_index | INDEX_TYPE_A,
            DNS_TYPE_AAAA => self.type_index = self.type_index | INDEX_TYPE_AAAA,
            DNS_TYPE_CNAME => self.type_index = self.type_index | INDEX_TYPE_CNAME,
            DNS_TYPE_MX => self.type_index = self.type_index | INDEX_TYPE_MX,
            DNS_TYPE_PTR => self.type_index = self.type_index | INDEX_TYPE_PTR,
            DNS_TYPE_RRSIG => self.type_index = self.type_index | INDEX_TYPE_RRSIG,
            DNS_TYPE_SOA => self.type_index = self.type_index | INDEX_TYPE_SOA,
            DNS_TYPE_SRV => self.type_index = self.type_index | INDEX_TYPE_SRV,
            DNS_TYPE_TXT => self.type_index = self.type_index | INDEX_TYPE_TXT,
            DNS_TYPE_DNS_KEY => self.type_index = self.type_index | INDEX_TYPE_DNSKEY,
            _ => {}
        };
    }

    fn has_type(&self, rtype: u16) -> bool {
        match rtype {
            DNS_TYPE_A => (self.type_index & INDEX_TYPE_A) == INDEX_TYPE_A,
            DNS_TYPE_AAAA => (self.type_index | INDEX_TYPE_AAAA) == INDEX_TYPE_AAAA,
            DNS_TYPE_CNAME => (self.type_index | INDEX_TYPE_CNAME) == INDEX_TYPE_CNAME,
            DNS_TYPE_MX => (self.type_index | INDEX_TYPE_MX) == INDEX_TYPE_MX,
            DNS_TYPE_PTR => (self.type_index | INDEX_TYPE_PTR) == INDEX_TYPE_PTR,
            DNS_TYPE_RRSIG => (self.type_index | INDEX_TYPE_RRSIG) == INDEX_TYPE_RRSIG,
            DNS_TYPE_SOA => (self.type_index | INDEX_TYPE_SOA) == INDEX_TYPE_SOA,
            DNS_TYPE_SRV => (self.type_index | INDEX_TYPE_SRV) == INDEX_TYPE_SRV,
            DNS_TYPE_TXT => (self.type_index | INDEX_TYPE_TXT) == INDEX_TYPE_TXT,
            DNS_TYPE_DNS_KEY => (self.type_index | INDEX_TYPE_DNSKEY) == INDEX_TYPE_DNSKEY,
            _ => false,
        }
    }

    pub fn decode(&mut self) {
        self.offset = 12;

        self.process_queries();
        self.process_answers();
    }

    fn process_queries(&mut self) {
        for _ in 0..self.question_count() {
            let mut query = Query::default();
            query.decode(self.raw_packet, self.offset, self.id());
            self.offset += query.qsize;

            self.set_index(query.rtype);
            self.query_list.push(query);
        }
    }

    fn process_answers(&mut self) {
        for _ in 0..self.answer_count() {
            let mut answer = Answer::default();
            answer.decode(self.raw_packet, self.offset, self.id());

            self.offset = answer.asize;
            self.set_index(answer.rtype);
            self.answer_list.push(answer);
        }
    }

    pub fn id(&self) -> u16 {
        BigEndian::read_u16(&self.raw_packet[0..2])
    }

    pub fn flags(&self) -> u16 {
        BigEndian::read_u16(&self.raw_packet[2..4])
    }

    pub fn is_query(&self) -> bool {
        (self.flags() & 0x8000) == 0
    }

    pub fn is_response(&self) -> bool {
        self.is_query() == false
    }

    pub fn opcode(&self) -> u8 {
        (self.flags() & 0x78) as u8
    }

    pub fn question_count(&self) -> u16 {
        BigEndian::read_u16(&self.raw_packet[4..6])
    }

    pub fn answer_count(&self) -> u16 {
        BigEndian::read_u16(&self.raw_packet[6..8])
    }

    pub fn authority_count(&self) -> u16 {
        BigEndian::read_u16(&self.raw_packet[8..10])
    }

    pub fn additional_count(&self) -> u16 {
        BigEndian::read_u16(&self.raw_packet[10..12])
    }

    pub fn is_authoritative(&self) -> bool {
        (self.flags() & 0x0400) == 0x0400
    }

    pub fn recursion_desired(&self) -> bool {
        (self.flags() & 0x0100) == 0x0100
    }

    pub fn recursion_available(&self) -> bool {
        (self.flags() & 0x80) == 0x80
    }

    pub fn answer_authenticated(&self) -> bool {
        (self.flags() & 0x20) == 0x20
    }

    pub fn non_authenticated(&self) -> bool {
        (self.flags() & 0x10) == 0x10
    }

    pub fn reply_code(&self) -> u8 {
        (self.flags() & 0x000f) as u8
    }

    pub fn has_rrsig(&self) -> bool {
        for anw in &self.answer_list {
            if anw.rrsig.is_some() {
                return true;
            }
        }

        false
    }

    pub fn has_aaaa(&self) -> bool {
        for anw in &self.answer_list {
            if anw.rtype == DNS_TYPE_AAAA {
                return true;
            }
        }

        false
    }
}

impl<'a> Layer for Dns<'a> {
    fn get_name(&self) -> String {
        "dns".to_string()
    }

    fn get_field(&self, field: String) -> Option<Field> {
        match field.as_str() {
            "dns.id" => Some(Field::set_field(FieldType::Int16(self.id()), field)),
            "dns.opcode" => Some(Field::set_field(FieldType::Int8(self.opcode()), field)),
            "dns.has_rrsig" => {
                Some(Field::set_field(
                    FieldType::Bool(self.has_type(DNS_TYPE_RRSIG)),
                    field,
                ))
                // Some(Field::set_field(FieldType::Bool(self.has_rrsig()), field))
            }
            "dns.has_aaaa" => Some(Field::set_field(
                FieldType::Bool(self.has_type(DNS_TYPE_AAAA)),
                field,
            )),
            // fields::DNS_HAS_AAAA => Some(Field::set_field(FieldType::Bool(self.has_aaaa()), field)),
            "dns.answer_count" => Some(Field::set_field(
                FieldType::Int16(self.answer_count()),
                field,
            )),
            "dns.type_a" => {
                let mut field_list: Vec<Box<FieldType>> = Vec::new();

                if !self.has_type(DNS_TYPE_A) {
                    return None;
                }
                for answer in &self.answer_list {
                    if answer.rtype == DNS_TYPE_A {
                        field_list.push(Box::new(FieldType::Ipv4(answer.ipv4_addr, 32)));
                    }
                }

                if field_list.len() > 0 {
                    Some(Field::set_field(FieldType::FieldArray(field_list), field))
                } else {
                    None
                }
            }
            "dns.question_count" => Some(Field::set_field(
                FieldType::Int16(self.question_count()),
                field,
            )),
            "dns.answers" => {
                let mut field_list: Vec<Box<FieldType>> = Vec::new();

                for answer in &self.answer_list {
                    field_list.push(Box::new(FieldType::String(answer.name.clone())));
                }

                Some(Field::set_field(FieldType::FieldArray(field_list), field))
            }
            _ => None,
        }
    }

    fn get_field_bytes(&self, _field_name: String) -> Option<Vec<u8>> {
        None
    }
}

fn get_name(raw_packet: &[u8], start_pos: usize, id: u16) -> (String, usize) {
    let mut offset = start_pos;
    let mut count: usize;
    let mut temp_name: String;
    let mut seperator = "";
    let mut label_ptr: u16;
    let mut label_offset = 0;
    let mut ptr = false;

    temp_name = String::new();
    loop {
        assert!(
            offset < raw_packet.len(),
            "Offset: {}, Packet len: {}",
            offset,
            raw_packet.len(),
        );

        count = raw_packet[offset] as usize;

        if count == 0 {
            if offset == start_pos {
                temp_name = String::from("<Root>");
            }
            break;
        }
        while count & 0xc0 == 0xc0 {
            ptr = true;

            label_ptr = BigEndian::read_u16(&raw_packet[offset..offset + 2]);
            offset = (label_ptr & 0x3fff) as usize;
            count = raw_packet[offset] as usize;
        }

        offset += 1;

        if (offset + count) > raw_packet.len() {
            eprintln!("==========================================================");
            eprintln!(
                "Error: ID: {:x} offset: {:x} count: {:x}, offset + count: {}, byte len: {}",
                id,
                offset,
                count,
                offset + count,
                raw_packet.len()
            );
            print_hex(raw_packet.to_vec());
            eprintln!("==========================================================");
            break;
        }

        if temp_name.len() != 0 {
            seperator = "."
        }

        match str::from_utf8(&raw_packet[offset..offset + count]) {
            Ok(name) => {
                temp_name = format!("{}{}{}", temp_name, seperator, name);
                if !ptr {
                    label_offset = temp_name.len() + 1;
                }
            }
            Err(msg) => {
                eprintln!(
                    "Error reading label: {}, ID: {:x}, offset: {:x}, count: {}, value: {:x}",
                    msg, id, offset, count, &raw_packet[offset]
                );
                print_hex(raw_packet[offset..offset + count].to_vec());
            }
        }

        offset += count;
    }

    if ptr {
        label_offset += 2;
    } else {
        label_offset += 1;
    }

    return (temp_name, label_offset);
}

//------------------------------------------------------
//------ Test section
//------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn dns_id() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x81, 0x80, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.id(), 0x117e, "DNS ID");
        assert_eq!(pkt.flags(), 0x8180, "DNS Flags");
        assert_eq!(pkt.question_count(), 1, "DNS Question");
    }

    #[test]
    fn dns_flags() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x81, 0x80, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.flags(), 0x8180, "DNS Flags");
    }

    #[test]
    fn dns_nbr_questions() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x81, 0x80, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.question_count(), 1, "DNS Question");
    }

    #[test]
    fn dns_is_query_false() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x81, 0x80, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.is_query(), false, "DNS is query");
    }

    #[test]
    fn dns_is_response_true() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x81, 0x80, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.is_response(), true, "DNS is response");
    }

    #[test]
    fn dns_is_query_true() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x01, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.is_query(), true, "DNS is query");
    }

    #[test]
    fn dns_is_response_false() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x01, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.is_response(), false, "DNS is response");
    }

    #[test]
    fn dns_opcode() {
        let packet: Vec<u8> = vec![
            0x11, 0x7e, 0x01, 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x20, 0x66,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.opcode(), 0, "DNS is query");
    }

    #[test]
    fn dns_is_authoritative_true() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.is_authoritative(), true, "DNS is authoritative");
    }

    #[test]
    fn dns_recursion_desired_true() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.recursion_desired(), true, "DNS recursion desired");
    }

    #[test]
    fn dns_recursion_available_true() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(
            pkt.recursion_available(),
            true,
            "DNS is recursion available"
        );
    }

    #[test]
    fn dns_answer_authenticated_false() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.answer_authenticated(), false, "DNS is authenticated");
    }

    #[test]
    fn dns_non_authenticated() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.non_authenticated(), false, "DNS is non authenticated");
    }

    #[test]
    fn dns_reply_code() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.reply_code(), 0, "DNS reply code = 0");
    }

    #[test]
    fn dns_qd_count() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.question_count(), 1, "DNS question count");
    }

    #[test]
    fn dns_answer_rr() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
            0x6c, 0x64, 0x61, 0x70, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x03, 0x70, 0x64, 0x63, 0x06,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.answer_count(), 1, "DNS answer count");
    }

    #[test]
    fn dns_authority_rr() {
        let packet: Vec<u8> = vec![
            0x7f, 0x19, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
            0x6c, 0x64, 0x61, 0x70, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x03, 0x70, 0x64, 0x63, 0x06,
        ];

        let pkt = Dns {
            raw_packet: &packet,
            answer_list: Vec::new(),
            query_list: Vec::new(),
            offset: 0,
            type_index: 0,
        };

        assert_eq!(pkt.answer_count(), 1, "DNS authority");
    }

    #[test]
    fn dns_process_query() {
        let packet: Vec<u8> = vec![
            0x9a, 0x04, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x76,
            0x31, 0x30, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x04, 0x64, 0x61, 0x74, 0x61,
            0x09, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x03, 0x63, 0x6f, 0x6d,
            0x00, 0x00, 0x01, 0x00, 0x01,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(pkt.query_list.len(), 1, "DNS question count should be 1");

        assert_eq!(
            pkt.query_list[0].name, "v10.events.data.microsoft.com",
            "DNS question name"
        );
    }

    #[test]
    fn dns_process_query_3_part_domain() {
        let packet: Vec<u8> = vec![
            0xd2, 0x33, 0x85, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x05, 0x5f,
            0x6c, 0x64, 0x61, 0x70, 0x04, 0x5f, 0x74, 0x63, 0x70, 0x03, 0x70, 0x64, 0x63, 0x06,
            0x5f, 0x6d, 0x73, 0x64, 0x63, 0x73, 0x07, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72,
            0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00, 0x00, 0x21, 0x00, 0x01, 0xc0, 0x0c, 0x00,
            0x21, 0x00, 0x01, 0x00, 0x00, 0x02, 0x58, 0x00, 0x21, 0x00, 0x00, 0x00, 0x64, 0x01,
            0x85, 0x0b, 0x6d, 0x74, 0x6c, 0x2d, 0x73, 0x72, 0x76, 0x2d, 0x61, 0x64, 0x32, 0x07,
            0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x05, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x00,
            0xc0, 0x47, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0e, 0x10, 0x00, 0x04, 0xc0, 0xa8,
            0x02, 0xe6,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(
            pkt.query_list[0].name, "_ldap._tcp.pdc._msdcs.lallier.local",
            "DNS question name"
        );
    }

    #[test]
    fn dns_process_query_1_reply() {
        let packet: Vec<u8> = vec![
            0x6d, 0xd, 0x81, 0x80, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x70, 0x69, 0x63,
            0x6f, 0x3, 0x67, 0x74, 0x6d, 0x4, 0x65, 0x73, 0x65, 0x74, 0x3, 0x43, 0x4f, 0x4d, 0x0,
            0x0, 0x1, 0x0, 0x1, 0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x6, 0x0, 0x4, 0x26,
            0x5a, 0xe2, 0x24, 0x0, 0x0, 0x29, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0,
        ];
        let pkt = Dns::new(&packet);

        assert_eq!(
            pkt.answer_list[0].name, "pico.gtm.eset.COM",
            "DNS question name"
        );
    }
    #[test]
    fn dns_process_query_3_replies() {
        let packet: Vec<u8> = vec![
            0xd8, 0xd9, 0x81, 0x80, 0x0, 0x1, 0x0, 0x3, 0x0, 0x0, 0x0, 0x0, 0x5, 0x73, 0x6c, 0x73,
            0x63, 0x72, 0x6, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x9, 0x6d, 0x69, 0x63, 0x72, 0x6f,
            0x73, 0x6f, 0x66, 0x74, 0x3, 0x63, 0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1, 0xc0, 0xc, 0x0,
            0x5, 0x0, 0x1, 0x0, 0x0, 0x7, 0x88, 0x0, 0x6, 0x3, 0x73, 0x6c, 0x73, 0xc0, 0x12, 0xc0,
            0x38, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0xc, 0xf3, 0x0, 0x2a, 0x3, 0x67, 0x6c, 0x62, 0x3,
            0x73, 0x6c, 0x73, 0x4, 0x70, 0x72, 0x6f, 0x64, 0x4, 0x64, 0x63, 0x61, 0x74, 0x3, 0x64,
            0x73, 0x70, 0xe, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x6d, 0x61, 0x6e, 0x61,
            0x67, 0x65, 0x72, 0x3, 0x6e, 0x65, 0x74, 0x0, 0xc0, 0x4a, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0,
            0x0, 0x82, 0x0, 0x4, 0x14, 0x36, 0x59, 0x6a,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 3, "DNS question with 3 replies");
    }

    #[test]
    fn dns_process_query_4_replies() {
        let packet: Vec<u8> = vec![
            0x8, 0x7b, 0x81, 0x80, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x9, 0x73, 0x63, 0x72,
            0x6f, 0x6f, 0x74, 0x63, 0x61, 0x32, 0x4, 0x6f, 0x63, 0x73, 0x70, 0xa, 0x73, 0x65, 0x63,
            0x6f, 0x6d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x3, 0x6e, 0x65, 0x74, 0x0, 0x0, 0x1, 0x0,
            0x1, 0xc0, 0xc, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1c, 0x0, 0x2a, 0x9, 0x73, 0x63,
            0x72, 0x6f, 0x6f, 0x74, 0x63, 0x61, 0x32, 0x4, 0x6f, 0x63, 0x73, 0x70, 0xa, 0x73, 0x65,
            0x63, 0x6f, 0x6d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x3, 0x6e, 0x65, 0x74, 0x9, 0x65, 0x64,
            0x67, 0x65, 0x73, 0x75, 0x69, 0x74, 0x65, 0xc0, 0x26, 0xc0, 0x3b, 0x0, 0x5, 0x0, 0x1,
            0x0, 0x0, 0x22, 0xaa, 0x0, 0x11, 0x5, 0x61, 0x31, 0x36, 0x39, 0x32, 0x1, 0x62, 0x6,
            0x61, 0x6b, 0x61, 0x6d, 0x61, 0x69, 0xc0, 0x26, 0xc0, 0x71, 0x0, 0x1, 0x0, 0x1, 0x0,
            0x0, 0x0, 0x14, 0x0, 0x4, 0x42, 0x82, 0x3f, 0x31, 0xc0, 0x71, 0x0, 0x1, 0x0, 0x1, 0x0,
            0x0, 0x0, 0x14, 0x0, 0x4, 0x42, 0x82, 0x3f, 0x30, 0x0, 0x0, 0x29, 0x2, 0x0, 0x0, 0x0,
            0x80, 0x0, 0x0, 0x0,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 4, "DNS question with 4 replies");
    }

    #[test]
    fn dns_process_1_query_1_replies_1_additional() {
        let packet: Vec<u8> = vec![
            0x9, 0x30, 0x81, 0x80, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0xc, 0x73, 0x61, 0x66,
            0x65, 0x62, 0x72, 0x6f, 0x77, 0x73, 0x69, 0x6e, 0x67, 0xa, 0x67, 0x6f, 0x6f, 0x67,
            0x6c, 0x65, 0x61, 0x70, 0x69, 0x73, 0x3, 0x63, 0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1,
            0xc0, 0xc, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x1, 0x11, 0x0, 0x4, 0xac, 0xd9, 0xd, 0x6a,
            0x0, 0x0, 0x29, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 1, "DNS answer 2 replies");
    }

    #[test]
    fn dns_process_dns_full() {
        let packet: Vec<u8> = vec![
            0x8, 0x7b, 0x81, 0x80, 0x0, 0x1, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1, 0x9, 0x73, 0x63, 0x72,
            0x6f, 0x6f, 0x74, 0x63, 0x61, 0x32, 0x4, 0x6f, 0x63, 0x73, 0x70, 0xa, 0x73, 0x65, 0x63,
            0x6f, 0x6d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x3, 0x6e, 0x65, 0x74, 0x0, 0x0, 0x1, 0x0,
            0x1, 0xc0, 0xc, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x1, 0x1c, 0x0, 0x2a, 0x9, 0x73, 0x63,
            0x72, 0x6f, 0x6f, 0x74, 0x63, 0x61, 0x32, 0x4, 0x6f, 0x63, 0x73, 0x70, 0xa, 0x73, 0x65,
            0x63, 0x6f, 0x6d, 0x74, 0x72, 0x75, 0x73, 0x74, 0x3, 0x6e, 0x65, 0x74, 0x9, 0x65, 0x64,
            0x67, 0x65, 0x73, 0x75, 0x69, 0x74, 0x65, 0xc0, 0x26, 0xc0, 0x3b, 0x0, 0x5, 0x0, 0x1,
            0x0, 0x0, 0x22, 0xaa, 0x0, 0x11, 0x5, 0x61, 0x31, 0x36, 0x39, 0x32, 0x1, 0x62, 0x6,
            0x61, 0x6b, 0x61, 0x6d, 0x61, 0x69, 0xc0, 0x26, 0xc0, 0x71, 0x0, 0x1, 0x0, 0x1, 0x0,
            0x0, 0x0, 0x14, 0x0, 0x4, 0x42, 0x82, 0x3f, 0x31, 0xc0, 0x71, 0x0, 0x1, 0x0, 0x1, 0x0,
            0x0, 0x0, 0x14, 0x0, 0x4, 0x42, 0x82, 0x3f, 0x30, 0x0, 0x0, 0x29, 0x2, 0x0, 0x0, 0x0,
            0x80, 0x0, 0x0, 0x0,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 4, "Answers list 4 record");
        assert_eq!(pkt.query_list.len(), 1, "Questions list 1 query");
    }

    #[test]
    fn dns_process_srv_record() {
        let packet: Vec<u8> = vec![
            0x92, 0xdf, 0x85, 0x80, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x5, 0x5f, 0x6c, 0x64,
            0x61, 0x70, 0x4, 0x5f, 0x74, 0x63, 0x70, 0x3, 0x70, 0x64, 0x63, 0x6, 0x5f, 0x6d, 0x73,
            0x64, 0x63, 0x73, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63,
            0x61, 0x6c, 0x0, 0x0, 0x21, 0x0, 0x1, 0xc0, 0xc, 0x0, 0x21, 0x0, 0x1, 0x0, 0x0, 0x2,
            0x58, 0x0, 0x21, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xb, 0x6d, 0x74, 0x6c, 0x2d, 0x73,
            0x72, 0x76, 0x2d, 0x61, 0x64, 0x32, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5,
            0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0x47, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10,
            0x0, 0x4, 0xc0, 0xa8, 0x2, 0xe6,
        ];

        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 1, "Answers list 1 SRV record");
        assert_eq!(pkt.answer_list[0].srv.port, 389, "SRV port == 389");
        assert_eq!(pkt.answer_list[0].srv.weight, 100, "SRV weigth == 100");
        assert_eq!(pkt.answer_list[0].srv.priority, 0, "SRV priority == 0");
    }

    #[test]
    fn dns_process_query_5_replies() {
        let packet: Vec<u8> = vec![
            0x2c, 0xa4, 0x81, 0x80, 0x0, 0x1, 0x0, 0x5, 0x0, 0x0, 0x0, 0x0, 0x3, 0x77, 0x77, 0x77,
            0x4, 0x62, 0x69, 0x6e, 0x67, 0x3, 0x63, 0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1, 0xc0, 0xc,
            0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x12, 0x16, 0x0, 0x2a, 0x6, 0x61, 0x2d, 0x30, 0x30, 0x30,
            0x31, 0xa, 0x61, 0x2d, 0x61, 0x66, 0x64, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x3, 0x6e, 0x65,
            0x74, 0xe, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x6d, 0x61, 0x6e, 0x61, 0x67,
            0x65, 0x72, 0x3, 0x6e, 0x65, 0x74, 0x0, 0xc0, 0x2a, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x0,
            0x3b, 0x0, 0x24, 0xc, 0x77, 0x77, 0x77, 0x2d, 0x62, 0x69, 0x6e, 0x67, 0x2d, 0x63, 0x6f,
            0x6d, 0xb, 0x64, 0x75, 0x61, 0x6c, 0x2d, 0x61, 0x2d, 0x30, 0x30, 0x30, 0x31, 0x8, 0x61,
            0x2d, 0x6d, 0x73, 0x65, 0x64, 0x67, 0x65, 0xc0, 0x4f, 0xc0, 0x60, 0x0, 0x5, 0x0, 0x1,
            0x0, 0x0, 0x0, 0x23, 0x0, 0x2, 0xc0, 0x6d, 0xc0, 0x90, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0,
            0x0, 0x23, 0x0, 0x4, 0xcc, 0x4f, 0xc5, 0xc8, 0xc0, 0x90, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0,
            0x0, 0x23, 0x0, 0x4, 0xd, 0x6b, 0x15, 0xc8,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 5, "DNS question with 5 replies");
        println!("Answer list: {:#?}", pkt.answer_list)
    }

    #[test]
    fn dns_query_rsig_answer() {
        let packet: Vec<u8> = vec![
            0xc0, 0xc, 0x0, 0x2e, 0x0, 0x1, 0x0, 0x0, 0x0, 0x17, 0x0, 0x5f, 0x0, 0x5, 0xd, 0x3,
            0x0, 0x0, 0x7, 0x8, 0x62, 0x38, 0xdf, 0xed, 0x62, 0x36, 0x3c, 0xed, 0x7a, 0xc5, 0x7,
            0x6e, 0x72, 0x2d, 0x64, 0x61, 0x74, 0x61, 0x3, 0x6e, 0x65, 0x74, 0x0, 0xe8, 0xc8, 0x4b,
            0x1, 0x33, 0x7d, 0xed, 0x12, 0x6e, 0x10, 0xa, 0xb6, 0x90, 0xfa, 0x94, 0x22, 0x22, 0x9a,
            0x49, 0x47, 0x99, 0xbd, 0x7c, 0x48, 0xef, 0x9d, 0xc4, 0x7e, 0x60, 0x5f, 0xad, 0x17,
            0x14, 0x60, 0x9a, 0xd1, 0x15, 0x41, 0x4a, 0x79, 0xfd, 0xf7, 0xe3, 0x78, 0x8f, 0x50,
            0x53, 0xc0, 0x33, 0x66, 0x39, 0x26, 0xf3, 0xe0, 0x7d, 0x91, 0x42, 0xc3, 0x42, 0xf1,
            0x78, 0xe0, 0xf3, 0xc3,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let mut answer = Answer::default();
        answer.decode(&packet, 0, 0xff);

        assert_eq!(answer.rrsig.is_some(), true, "DNS rrsig present");
        assert_eq!(
            answer.rrsig.as_ref().unwrap().type_covered,
            5,
            "DNS rrsig type covered"
        );
        assert_eq!(
            answer.rrsig.as_ref().unwrap().orig_ttl,
            1800,
            "DNS rrsig type covered"
        );
        assert_eq!(
            answer.rrsig.as_ref().unwrap().algorithm,
            13,
            "DNS rrsig type covered"
        );
        println!("{}", answer.rrsig.unwrap());
    }

    #[test]
    fn dns_process_query_7_replies() {
        let packet: Vec<u8> = vec![
            0x5a, 0x42, 0x81, 0x80, 0x0, 0x1, 0x0, 0x7, 0x0, 0x0, 0x0, 0x1, 0xa, 0x6c, 0x61, 0x6c,
            0x6c, 0x69, 0x65, 0x72, 0x2d, 0x6d, 0x79, 0xa, 0x73, 0x68, 0x61, 0x72, 0x65, 0x70,
            0x6f, 0x69, 0x6e, 0x74, 0x3, 0x63, 0x6f, 0x6d, 0x0, 0x0, 0x1, 0x0, 0x1, 0xc0, 0xc, 0x0,
            0x5, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0xa, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65,
            0x72, 0xc0, 0x17, 0xc0, 0x37, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x1e, 0xa,
            0x32, 0x35, 0x37, 0x37, 0x2d, 0x69, 0x70, 0x76, 0x34, 0x65, 0x5, 0x63, 0x6c, 0x75,
            0x6d, 0x70, 0x4, 0x70, 0x72, 0x6f, 0x64, 0x5, 0x61, 0x61, 0x2d, 0x72, 0x74, 0xc0, 0x17,
            0xc0, 0x4d, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x13, 0xb, 0x32, 0x30, 0x31,
            0x36, 0x31, 0x2d, 0x69, 0x70, 0x76, 0x34, 0x65, 0x4, 0x66, 0x61, 0x72, 0x6d, 0xc0,
            0x5e, 0xc0, 0x77, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x0, 0x3c, 0x0, 0x37, 0xb, 0x32, 0x30,
            0x31, 0x36, 0x31, 0x2d, 0x69, 0x70, 0x76, 0x34, 0x65, 0x4, 0x66, 0x61, 0x72, 0x6d, 0x4,
            0x70, 0x72, 0x6f, 0x64, 0x10, 0x73, 0x68, 0x61, 0x72, 0x65, 0x70, 0x6f, 0x69, 0x6e,
            0x74, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x3, 0x63, 0x6f, 0x6d, 0x6, 0x61, 0x6b, 0x61,
            0x64, 0x6e, 0x73, 0x3, 0x6e, 0x65, 0x74, 0x0, 0xc0, 0x96, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0,
            0x1, 0x2c, 0x0, 0x45, 0xa, 0x32, 0x30, 0x31, 0x36, 0x31, 0x2d, 0x69, 0x70, 0x76, 0x34,
            0x4, 0x66, 0x61, 0x72, 0x6d, 0x4, 0x70, 0x72, 0x6f, 0x64, 0x5, 0x61, 0x61, 0x2d, 0x72,
            0x74, 0xa, 0x73, 0x68, 0x61, 0x72, 0x65, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x3, 0x63, 0x6f,
            0x6d, 0xd, 0x64, 0x75, 0x61, 0x6c, 0x2d, 0x73, 0x70, 0x6f, 0x2d, 0x30, 0x30, 0x30,
            0x34, 0xa, 0x73, 0x70, 0x6f, 0x2d, 0x6d, 0x73, 0x65, 0x64, 0x67, 0x65, 0xc0, 0xc8,
            0xc0, 0xd9, 0x0, 0x5, 0x0, 0x1, 0x0, 0x0, 0x0, 0xf0, 0x0, 0xd, 0xa, 0x32, 0x30, 0x31,
            0x36, 0x31, 0x2d, 0x69, 0x70, 0x76, 0x34, 0xc0, 0x83, 0xc1, 0x2a, 0x0, 0x1, 0x0, 0x1,
            0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0x28, 0x6c, 0xd1, 0x1f, 0x0, 0x0, 0x29, 0x2, 0x0, 0x0,
            0x0, 0x80, 0x0, 0x0, 0x0,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 7, "DNS question with 7 replies");
        for a in pkt.answer_list {
            println!("{:#?}", a);
        }
    }

    #[test]
    fn dns_process_soa() {
        let packet: Vec<u8> = vec![
            0x10, 0xd2, 0x81, 0xa0, 0x0, 0x1, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1, 0x3, 0x31, 0x39, 0x32,
            0x7, 0x69, 0x6e, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x4, 0x61, 0x72, 0x70, 0x61, 0x0, 0x0,
            0x6, 0x0, 0x1, 0xc0, 0xc, 0x0, 0x6, 0x0, 0x1, 0x0, 0x0, 0x4e, 0x53, 0x0, 0x2a, 0x1,
            0x7a, 0x4, 0x61, 0x72, 0x69, 0x6e, 0x3, 0x6e, 0x65, 0x74, 0x0, 0x7, 0x64, 0x6e, 0x73,
            0x2d, 0x6f, 0x70, 0x73, 0xc0, 0x30, 0x78, 0x39, 0x7c, 0xbe, 0x0, 0x0, 0x7, 0x8, 0x0,
            0x0, 0x3, 0x84, 0x0, 0xa, 0x8c, 0x0, 0x0, 0x0, 0x2a, 0x30, 0xc0, 0xc, 0x0, 0x2e, 0x0,
            0x1, 0x0, 0x0, 0x4e, 0x53, 0x0, 0xa4, 0x0, 0x6, 0x8, 0x3, 0x0, 0x1, 0x51, 0x80, 0x62,
            0x49, 0xcc, 0x33, 0x62, 0x37, 0x49, 0x23, 0x56, 0x6d, 0x3, 0x31, 0x39, 0x32, 0x7, 0x69,
            0x6e, 0x2d, 0x61, 0x64, 0x64, 0x72, 0x4, 0x61, 0x72, 0x70, 0x61, 0x0, 0x26, 0xcc, 0x59,
            0x6, 0x54, 0xe5, 0xde, 0x80, 0xf8, 0x9d, 0xf3, 0x7a, 0x27, 0x43, 0x2f, 0xf6, 0xee,
            0x27, 0x8e, 0xdf, 0xdd, 0xee, 0x17, 0x91, 0xa5, 0x25, 0x92, 0x64, 0xd0, 0x57, 0x10,
            0x23, 0xa4, 0x4c, 0x50, 0x22, 0xc6, 0xbe, 0x28, 0x24, 0x1, 0x37, 0x7, 0xea, 0x8c, 0x81,
            0xca, 0xa6, 0x39, 0x7f, 0x29, 0x5a, 0x14, 0xcb, 0x3a, 0x13, 0xd9, 0x5c, 0x5, 0x46,
            0xb2, 0x85, 0xc6, 0x59, 0x7b, 0x5b, 0xcd, 0x4d, 0x4c, 0xdb, 0x83, 0x6d, 0xc8, 0x2c,
            0xf9, 0x1d, 0xc1, 0x5f, 0x70, 0x1c, 0xd6, 0xa9, 0x6f, 0x6c, 0xa3, 0xd, 0x9e, 0x33,
            0x6f, 0x4c, 0x94, 0x52, 0x98, 0xd, 0x55, 0xc7, 0x3c, 0x7b, 0x91, 0x1c, 0xcc, 0x28,
            0x43, 0x13, 0x67, 0x2, 0xa, 0x21, 0xad, 0x3d, 0x17, 0xc, 0x2c, 0x51, 0x64, 0x47, 0x2,
            0xd8, 0xc4, 0x9c, 0x4, 0xea, 0x81, 0x60, 0x65, 0xd, 0xcb, 0x93, 0x0, 0x0, 0x29, 0x2,
            0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let mut answer = Answer::default();
        answer.decode(&packet, 0x22, 0xeeee);

        assert_eq!(answer.soa.is_some(), true, "DNS SOA answer");
        println!(
            "SOA test: {}, Answer: {}",
            answer.clone().soa.unwrap(),
            answer.clone()
        );
    }

    #[test]
    fn dns_ldap_srv() {
        let packet: Vec<u8> = vec![
            0xd7, 0x28, 0x85, 0x80, 0x0, 0x1, 0x0, 0x7, 0x0, 0x0, 0x0, 0x7, 0x5, 0x5f, 0x6c, 0x64,
            0x61, 0x70, 0x4, 0x5f, 0x74, 0x63, 0x70, 0x2, 0x64, 0x63, 0x6, 0x5f, 0x6d, 0x73, 0x64,
            0x63, 0x73, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63, 0x61,
            0x6c, 0x0, 0x0, 0x21, 0x0, 0x1, 0xc0, 0xc, 0x0, 0x21, 0x0, 0x1, 0x0, 0x0, 0x2, 0x58,
            0x0, 0x21, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xb, 0x6d, 0x74, 0x6c, 0x2d, 0x73, 0x72,
            0x76, 0x2d, 0x61, 0x64, 0x32, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c,
            0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0xc, 0x0, 0x21, 0x0, 0x1, 0x0, 0x0, 0x2, 0x58, 0x0,
            0x22, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xc, 0x72, 0x65, 0x70, 0x74, 0x2d, 0x73, 0x72,
            0x76, 0x2d, 0x61, 0x64, 0x32, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c,
            0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0xc, 0x0, 0x21, 0x0, 0x1, 0x0, 0x0, 0x2, 0x58, 0x0,
            0x22, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xc, 0x6c, 0x70, 0x61, 0x74, 0x2d, 0x73, 0x72,
            0x76, 0x2d, 0x61, 0x64, 0x32, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c,
            0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0xc, 0x0, 0x21, 0x0, 0x1, 0x0, 0x0, 0x2, 0x58, 0x0,
            0x25, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xf, 0x77, 0x69, 0x6e, 0x2d, 0x6f, 0x64, 0x34,
            0x6e, 0x69, 0x6d, 0x34, 0x6d, 0x38, 0x72, 0x63, 0x7, 0x6c, 0x61, 0x6c, 0x6c, 0x69,
            0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0xc, 0x0, 0x21, 0x0, 0x1,
            0x0, 0x0, 0x2, 0x58, 0x0, 0x22, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xc, 0x6c, 0x6b, 0x69,
            0x61, 0x2d, 0x73, 0x72, 0x76, 0x2d, 0x61, 0x64, 0x32, 0x7, 0x6c, 0x61, 0x6c, 0x6c,
            0x69, 0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0xc, 0x0, 0x21, 0x0,
            0x1, 0x0, 0x0, 0x2, 0x58, 0x0, 0x22, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xc, 0x73, 0x68,
            0x61, 0x72, 0x65, 0x2d, 0x73, 0x72, 0x76, 0x2d, 0x61, 0x64, 0x7, 0x6c, 0x61, 0x6c,
            0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0xc, 0x0, 0x21,
            0x0, 0x1, 0x0, 0x0, 0x2, 0x58, 0x0, 0x22, 0x0, 0x0, 0x0, 0x64, 0x1, 0x85, 0xc, 0x68,
            0x75, 0x6c, 0x6c, 0x2d, 0x73, 0x72, 0x76, 0x2d, 0x61, 0x64, 0x32, 0x7, 0x6c, 0x61,
            0x6c, 0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0, 0xc0, 0x46, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xc0, 0xa8, 0x2, 0xe6, 0xc0, 0x73, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xc0, 0xa8, 0x1, 0xe6, 0xc0, 0xa1, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xa, 0x9, 0x12, 0xe6, 0xc0, 0xcf, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0x4, 0xb0, 0x0, 0x4, 0xa, 0x9, 0x12, 0xe6, 0xc1, 0x0, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xc0, 0xa8, 0x6, 0xe6, 0xc1, 0x2e, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xc0, 0xa8, 0xfc, 0xe8, 0xc1, 0x5c, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xc0, 0xa8, 0x3, 0xe6,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let pkt = Dns::new(&packet);

        assert_eq!(pkt.answer_list.len(), 7, "DNS question with 7 replies");
        for a in pkt.answer_list {
            println!("{:#?}", a);
        }
    }

    #[test]
    fn dns_soa_name_jump_to_offset() {
        let packet: Vec<u8> = vec![
            0x41, 0xf8, 0x85, 0x80, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x7, 0x6c, 0x61, 0x6c,
            0x6c, 0x69, 0x65, 0x72, 0x5, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x0, 0x0, 0x6, 0x0, 0x1,
            0xc0, 0xc, 0x0, 0x6, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x2f, 0xc, 0x68, 0x75, 0x6c,
            0x6c, 0x2d, 0x73, 0x72, 0x76, 0x2d, 0x61, 0x64, 0x32, 0xc0, 0xc, 0xa, 0x68, 0x6f, 0x73,
            0x74, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x0, 0x0, 0x9, 0xd6, 0xd0, 0x0, 0x0, 0x3,
            0x84, 0x0, 0x0, 0x2, 0x58, 0x0, 0x1, 0x51, 0x80, 0x0, 0x0, 0xe, 0x10, 0xc0, 0x2b, 0x0,
            0x1, 0x0, 0x1, 0x0, 0x0, 0xe, 0x10, 0x0, 0x4, 0xc0, 0xa8, 0x3, 0xe6,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let pkt = Dns::new(&packet);

        for a in pkt.answer_list {
            println!("{:#?}", a);
        }
    }

    #[test]
    fn dns_answer_aaaa() {
        let packet: Vec<u8> = vec![
            0xc0, 0xc, 0x0, 0x1c, 0x0, 0x1, 0x0, 0x0, 0x4c, 0x89, 0x0, 0x10, 0x20, 0x1, 0x5, 0x0,
            0x0, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x63,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let mut answer = Answer::default();
        answer.decode(&packet, 0, 0xff);

        println!("AAAA : {}", answer);
        assert_eq!(
            answer.ipv6_addr, 0x20010500001300000000000000000063,
            "DNS ipv6 address"
        );
    }

    #[test]
    fn dns_query_only_long_question_name() {
        let packet: Vec<u8> = vec![
            0x3f, 0x75, 0x73, 0x72, 0x63, 0x75, 0x61, 0x61, 0x63, 0x61, 0x61, 0x6b, 0x70, 0x61,
            0x69, 0x71, 0x64, 0x61, 0x68, 0x76, 0x73, 0x65, 0x61, 0x36, 0x73, 0x61, 0x71, 0x61,
            0x61, 0x61, 0x7a, 0x6a, 0x67, 0x75, 0x69, 0x6a, 0x63, 0x34, 0x6c, 0x6d, 0x78, 0x75,
            0x71, 0x6e, 0x33, 0x34, 0x69, 0x71, 0x64, 0x61, 0x65, 0x61, 0x61, 0x61, 0x61, 0x61,
            0x33, 0x61, 0x61, 0x61, 0x61, 0x61, 0x32, 0x70, 0x30, 0x70, 0x76, 0x6c, 0x61, 0x61,
            0x63, 0x61, 0x61, 0x77, 0x61, 0x61, 0x6a, 0x71, 0x61, 0x36, 0x37, 0x33, 0x70, 0x61,
            0x70, 0x67, 0x68, 0x34, 0x37, 0x79, 0x74, 0x6a, 0x75, 0x74, 0x64, 0x35, 0x6a, 0x73,
            0x33, 0x37, 0x61, 0x79, 0x75, 0x35, 0x73, 0x34, 0x6c, 0x6d, 0x62, 0x72, 0x79, 0x61,
            0x69, 0x1, 0x61, 0x1, 0x6a, 0x2, 0x65, 0x35, 0x2, 0x73, 0x6b, 0x0, 0x0, 0x10, 0x0, 0x1,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let mut query = Query::default();
        query.decode(&packet, 0, 0xfe);

        assert_eq!(query.rtype, DNS_TYPE_TXT, "DNS ipv6 address");

        println!("Query name: {}", query.name);
    }

    #[test]
    fn dns_query_with_long_question_name_no_answer() {
        let packet: Vec<u8> = vec![
            0x88, 0x7, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3f, 0x75, 0x73, 0x72,
            0x63, 0x75, 0x61, 0x61, 0x63, 0x61, 0x61, 0x6b, 0x70, 0x61, 0x69, 0x71, 0x64, 0x61,
            0x68, 0x76, 0x73, 0x65, 0x61, 0x36, 0x73, 0x61, 0x71, 0x61, 0x61, 0x61, 0x7a, 0x6a,
            0x67, 0x75, 0x69, 0x6a, 0x63, 0x34, 0x6c, 0x6d, 0x78, 0x75, 0x71, 0x6e, 0x33, 0x34,
            0x69, 0x71, 0x64, 0x61, 0x65, 0x61, 0x61, 0x61, 0x61, 0x61, 0x33, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x32, 0x70, 0x30, 0x70, 0x76, 0x6c, 0x61, 0x61, 0x63, 0x61, 0x61, 0x77,
            0x61, 0x61, 0x6a, 0x71, 0x61, 0x36, 0x37, 0x33, 0x70, 0x61, 0x70, 0x67, 0x68, 0x34,
            0x37, 0x79, 0x74, 0x6a, 0x75, 0x74, 0x64, 0x35, 0x6a, 0x73, 0x33, 0x37, 0x61, 0x79,
            0x75, 0x35, 0x73, 0x34, 0x6c, 0x6d, 0x62, 0x72, 0x79, 0x61, 0x69, 0x1, 0x61, 0x1, 0x6a,
            0x2, 0x65, 0x35, 0x2, 0x73, 0x6b, 0x0, 0x0, 0x10, 0x0, 0x1, 0x0, 0x0, 0x29, 0xf, 0xa0,
            0x0, 0x0, 0x80, 0x0, 0x0, 0x0,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let dns = Dns::new(&packet);

        assert_eq!(dns.answer_count(), 0, "DNS ipv6 address");

        println!("DNS: {:?}", dns);
    }

    #[test]
    fn dns_query_with_long_question_name_long_answer() {
        let packet: Vec<u8> = vec![
            0x88, 0x7, 0x81, 0x80, 0x0, 0x1, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x3f, 0x75, 0x73, 0x72,
            0x63, 0x75, 0x61, 0x61, 0x63, 0x61, 0x61, 0x6b, 0x70, 0x61, 0x69, 0x71, 0x64, 0x61,
            0x68, 0x76, 0x73, 0x65, 0x61, 0x36, 0x73, 0x61, 0x71, 0x61, 0x61, 0x61, 0x7a, 0x6a,
            0x67, 0x75, 0x69, 0x6a, 0x63, 0x34, 0x6c, 0x6d, 0x78, 0x75, 0x71, 0x6e, 0x33, 0x34,
            0x69, 0x71, 0x64, 0x61, 0x65, 0x61, 0x61, 0x61, 0x61, 0x61, 0x33, 0x61, 0x61, 0x61,
            0x61, 0x61, 0x32, 0x70, 0x30, 0x70, 0x76, 0x6c, 0x61, 0x61, 0x63, 0x61, 0x61, 0x77,
            0x61, 0x61, 0x6a, 0x71, 0x61, 0x36, 0x37, 0x33, 0x70, 0x61, 0x70, 0x67, 0x68, 0x34,
            0x37, 0x79, 0x74, 0x6a, 0x75, 0x74, 0x64, 0x35, 0x6a, 0x73, 0x33, 0x37, 0x61, 0x79,
            0x75, 0x35, 0x73, 0x34, 0x6c, 0x6d, 0x62, 0x72, 0x79, 0x61, 0x69, 0x1, 0x61, 0x1, 0x6a,
            0x2, 0x65, 0x35, 0x2, 0x73, 0x6b, 0x0, 0x0, 0x10, 0x0, 0x1, 0xc0, 0xc, 0x0, 0x10, 0x0,
            0x1, 0x0, 0x0, 0x0, 0x78, 0x0, 0xad, 0xac, 0x41, 0x47, 0x41, 0x53, 0x4b, 0x67, 0x41,
            0x43, 0x41, 0x42, 0x51, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x30,
            0x67, 0x51, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
            0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x49, 0x41, 0x41, 0x41, 0x42, 0x57, 0x41,
            0x41, 0x41, 0x41, 0x51, 0x53, 0x34, 0x35, 0x57, 0x51, 0x45, 0x41, 0x45, 0x77, 0x41,
            0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
            0x41, 0x44, 0x43, 0x49, 0x32, 0x6c, 0x43, 0x66, 0x43, 0x5a, 0x37, 0x79, 0x51, 0x64,
            0x42, 0x6f, 0x43, 0x51, 0x2b, 0x43, 0x49, 0x6c, 0x44, 0x55, 0x72, 0x6d, 0x76, 0x65,
            0x6a, 0x37, 0x62, 0x73, 0x32, 0x45, 0x6d, 0x67, 0x46, 0x76, 0x33, 0x68, 0x45, 0x58,
            0x5a, 0x53, 0x37, 0x34, 0x7a, 0x33, 0x73, 0x75, 0x6e, 0x6d, 0x2b, 0x52, 0x34, 0x56,
            0x4b, 0x4c, 0x53, 0x4d, 0x4b, 0x47, 0x4f, 0x32, 0x37, 0x6c, 0x75, 0x42, 0x36, 0x62,
            0x50, 0x38, 0x78, 0x33, 0x53, 0x2f, 0x64, 0x68, 0x36, 0x6c, 0x46, 0x74, 0x48, 0x78,
            0x50, 0x45, 0x4e, 0x41, 0x33, 0x76, 0x37, 0x65, 0x42, 0x34, 0x47, 0x0, 0x0, 0x29, 0x2,
            0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let dns = Dns::new(&packet);

        assert_eq!(dns.answer_count(), 1, "DNS long answer 1");
        assert_eq!(dns.question_count(), 1, "DNS long query 1");
        assert_eq!(dns.additional_count(), 1, "DNS long additional 1");
        assert_eq!(
            dns.answer_list[0].name,
            "usrcuaacaakpaiqdahvsea6saqaaazjguijc4lmxuqn34iqdaeaaaaa3aaaaa2p.pvlaacaawaajqa673papgh47ytjutd5js37ayu5s4lmbryai.a.j.e5.sk",
            "DNS long additional 1"
        );

        println!("DNS: {:?}", dns);
    }

    #[test]
    fn dns_query_dnskey() {
        let packet: Vec<u8> = vec![
            0xb3, 0x60, 0x81, 0xa0, 0x0, 0x1, 0x0, 0x3, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x30, 0x0,
            0x1, 0x0, 0x0, 0x30, 0x0, 0x1, 0x0, 0x0, 0xd6, 0xd5, 0x1, 0x8, 0x1, 0x0, 0x3, 0x8, 0x3,
            0x1, 0x0, 0x1, 0x9c, 0xa6, 0xe0, 0x70, 0x96, 0x89, 0x30, 0x0, 0x97, 0x63, 0x2f, 0xd6,
            0x2c, 0xe0, 0x4f, 0x29, 0xfd, 0xb0, 0xac, 0x20, 0x8b, 0x97, 0x81, 0xc6, 0x91, 0xb6,
            0xf5, 0xb5, 0x65, 0x79, 0xfa, 0xbf, 0xaf, 0xe4, 0xc6, 0xa, 0xd9, 0x94, 0x12, 0x5b,
            0xc5, 0xc8, 0x15, 0x87, 0x46, 0x3b, 0xdf, 0xf6, 0x60, 0x60, 0x94, 0x89, 0x53, 0x5,
            0x1b, 0x1e, 0xdb, 0x67, 0x6f, 0xcc, 0xd3, 0x88, 0xf9, 0xc6, 0x2b, 0x92, 0x30, 0xfa,
            0x2c, 0xe1, 0xee, 0xc4, 0xca, 0x1c, 0xfd, 0xde, 0x16, 0xb5, 0x75, 0x8a, 0x76, 0xf8,
            0x8d, 0x9a, 0xbb, 0x56, 0x17, 0x61, 0xa9, 0x8e, 0x60, 0xce, 0x23, 0xdf, 0x20, 0x2d,
            0xde, 0x1, 0x67, 0x45, 0x3f, 0x95, 0x8f, 0x38, 0xee, 0x62, 0x4f, 0xf4, 0xbc, 0xa9,
            0x14, 0x0, 0x59, 0x70, 0x49, 0xf7, 0xcc, 0xcd, 0xef, 0x71, 0xee, 0x4, 0x7b, 0x50, 0x37,
            0xba, 0x94, 0xa5, 0x15, 0xd, 0x93, 0x17, 0x22, 0x52, 0xf, 0xd1, 0xef, 0x32, 0x73, 0xf8,
            0x5e, 0x77, 0x85, 0x7b, 0x10, 0x71, 0x57, 0xde, 0x91, 0xa4, 0xb7, 0x32, 0xd8, 0xef,
            0xae, 0xd9, 0x6e, 0x82, 0x84, 0x88, 0x83, 0xa, 0x39, 0x6b, 0xa3, 0x3, 0xc2, 0x71, 0x4d,
            0xf3, 0x5d, 0xf5, 0xf1, 0xc9, 0x6c, 0xbf, 0x54, 0xa3, 0x3a, 0x4c, 0xe6, 0xbc, 0x80,
            0xd7, 0xfe, 0x68, 0xa6, 0x95, 0x91, 0xcb, 0xff, 0x78, 0x88, 0x79, 0x7a, 0xbf, 0x2b,
            0xae, 0xca, 0x80, 0x8b, 0xd2, 0x93, 0xf0, 0xee, 0x61, 0x9a, 0x1c, 0xd8, 0x2e, 0x45,
            0xe, 0x40, 0x45, 0xd5, 0x49, 0x13, 0x91, 0x57, 0x44, 0x4c, 0xb7, 0xd9, 0x77, 0x25,
            0x2c, 0x16, 0xc5, 0x3d, 0x4c, 0x79, 0xb1, 0x3, 0xbe, 0xd7, 0xc1, 0x6a, 0xd, 0xee, 0xa3,
            0xe9, 0x99, 0xc1, 0x64, 0x85, 0x96, 0x97, 0x3d, 0x92, 0xec, 0xf2, 0x58, 0x17, 0x7b,
            0xd8, 0x47, 0x0, 0x0, 0x30, 0x0, 0x1, 0x0, 0x0, 0xd6, 0xd5, 0x1, 0x8, 0x1, 0x1, 0x3,
            0x8, 0x3, 0x1, 0x0, 0x1, 0xac, 0xff, 0xb4, 0x9, 0xbc, 0xc9, 0x39, 0xf8, 0x31, 0xf7,
            0xa1, 0xe5, 0xec, 0x88, 0xf7, 0xa5, 0x92, 0x55, 0xec, 0x53, 0x4, 0xb, 0xe4, 0x32, 0x2,
            0x73, 0x90, 0xa4, 0xce, 0x89, 0x6d, 0x6f, 0x90, 0x86, 0xf3, 0xc5, 0xe1, 0x77, 0xfb,
            0xfe, 0x11, 0x81, 0x63, 0xaa, 0xec, 0x7a, 0xf1, 0x46, 0x2c, 0x47, 0x94, 0x59, 0x44,
            0xc4, 0xe2, 0xc0, 0x26, 0xbe, 0x5e, 0x98, 0xbb, 0xcd, 0xed, 0x25, 0x97, 0x82, 0x72,
            0xe1, 0xe3, 0xe0, 0x79, 0xc5, 0x9, 0x4d, 0x57, 0x3f, 0xe, 0x83, 0xc9, 0x2f, 0x2, 0xb3,
            0x2d, 0x35, 0x13, 0xb1, 0x55, 0xb, 0x82, 0x69, 0x29, 0xc8, 0xd, 0xd0, 0xf9, 0x2c, 0xac,
            0x96, 0x6d, 0x17, 0x76, 0x9f, 0xd5, 0x86, 0x7b, 0x64, 0x7c, 0x3f, 0x38, 0x2, 0x9a,
            0xbd, 0xc4, 0x81, 0x52, 0xeb, 0x8f, 0x20, 0x71, 0x59, 0xec, 0xc5, 0xd2, 0x32, 0xc7,
            0xc1, 0x53, 0x7c, 0x79, 0xf4, 0xb7, 0xac, 0x28, 0xff, 0x11, 0x68, 0x2f, 0x21, 0x68,
            0x1b, 0xf6, 0xd6, 0xab, 0xa5, 0x55, 0x3, 0x2b, 0xf6, 0xf9, 0xf0, 0x36, 0xbe, 0xb2,
            0xaa, 0xa5, 0xb3, 0x77, 0x8d, 0x6e, 0xeb, 0xfb, 0xa6, 0xbf, 0x9e, 0xa1, 0x91, 0xbe,
            0x4a, 0xb0, 0xca, 0xea, 0x75, 0x9e, 0x2f, 0x77, 0x3a, 0x1f, 0x90, 0x29, 0xc7, 0x3e,
            0xcb, 0x8d, 0x57, 0x35, 0xb9, 0x32, 0x1d, 0xb0, 0x85, 0xf1, 0xb8, 0xe2, 0xd8, 0x3,
            0x8f, 0xe2, 0x94, 0x19, 0x92, 0x54, 0x8c, 0xee, 0xd, 0x67, 0xdd, 0x45, 0x47, 0xe1,
            0x1d, 0xd6, 0x3a, 0xf9, 0xc9, 0xfc, 0x1c, 0x54, 0x66, 0xfb, 0x68, 0x4c, 0xf0, 0x9,
            0xd7, 0x19, 0x7c, 0x2c, 0xf7, 0x9e, 0x79, 0x2a, 0xb5, 0x1, 0xe6, 0xa8, 0xa1, 0xca,
            0x51, 0x9a, 0xf2, 0xcb, 0x9b, 0x5f, 0x63, 0x67, 0xe9, 0x4c, 0xd, 0x47, 0x50, 0x24,
            0x51, 0x35, 0x7b, 0xe1, 0xb5, 0x0, 0x0, 0x2e, 0x0, 0x1, 0x0, 0x0, 0xd6, 0xd5, 0x1,
            0x13, 0x0, 0x30, 0x8, 0x0, 0x0, 0x2, 0xa3, 0x0, 0x62, 0x47, 0x92, 0x0, 0x62, 0x2b,
            0xe2, 0x80, 0x4f, 0x66, 0x0, 0xd, 0xaf, 0xfa, 0xae, 0xe2, 0x1b, 0x2e, 0x62, 0x54, 0x4f,
            0xb, 0x1, 0x8a, 0xed, 0x4f, 0x1f, 0xc3, 0x86, 0xe9, 0xa1, 0x8, 0x80, 0xd, 0x93, 0x81,
            0xbb, 0x6b, 0x8f, 0xeb, 0xf7, 0x5c, 0xfe, 0x58, 0xde, 0x96, 0x47, 0xc1, 0x90, 0x2d,
            0xa8, 0x4c, 0xcf, 0x31, 0xa5, 0xd3, 0x57, 0xee, 0xee, 0xeb, 0xc0, 0xb3, 0x3e, 0xfc,
            0x42, 0x22, 0x4, 0xeb, 0xf6, 0xa5, 0xff, 0x4, 0x2e, 0x25, 0xa6, 0x49, 0x3a, 0xb7, 0x8b,
            0x1d, 0x14, 0xd6, 0xba, 0xd6, 0x5, 0xb7, 0x76, 0xfb, 0xdc, 0xdd, 0x2b, 0xee, 0x16,
            0xfe, 0xcf, 0x6e, 0xd4, 0xd4, 0x3e, 0x28, 0x92, 0xbb, 0x4b, 0xbd, 0x31, 0x62, 0xb4,
            0xb2, 0xba, 0xe4, 0x55, 0x1c, 0x41, 0x66, 0xed, 0xae, 0x18, 0xa5, 0x92, 0x90, 0x3a,
            0x12, 0x3e, 0x32, 0xd3, 0x18, 0x8e, 0xa7, 0xf5, 0x44, 0x55, 0x8f, 0xaf, 0x55, 0x86,
            0xb4, 0x6e, 0xb7, 0xd7, 0xdf, 0x8, 0x81, 0x9b, 0xe9, 0x98, 0x66, 0x4, 0x71, 0xbb, 0xc5,
            0xfe, 0xe9, 0xc6, 0x8f, 0x86, 0xe8, 0xd1, 0x60, 0x1a, 0x60, 0xb6, 0x55, 0x12, 0xfa,
            0x80, 0x1c, 0x45, 0x7a, 0x35, 0xda, 0x24, 0xce, 0x13, 0x25, 0x91, 0xb, 0x5b, 0xab,
            0x9a, 0xf3, 0xce, 0xc3, 0x69, 0x34, 0x95, 0xfa, 0x5, 0x8b, 0xd4, 0xda, 0xf1, 0x47, 0xf,
            0x3a, 0x67, 0x39, 0x5b, 0xe3, 0x94, 0xde, 0x6c, 0x91, 0xe0, 0xb3, 0x32, 0xce, 0x6f,
            0xbe, 0x8b, 0x23, 0xc5, 0x8a, 0x4a, 0x26, 0xe8, 0xca, 0x27, 0xb5, 0x88, 0xf3, 0x7,
            0x97, 0x84, 0x40, 0xf, 0xb7, 0xbb, 0x58, 0xa5, 0x93, 0xa9, 0xa1, 0xd1, 0x63, 0x75,
            0xb5, 0xaa, 0xa7, 0xf, 0x37, 0x7f, 0x8b, 0xf6, 0x95, 0x7c, 0x6, 0x97, 0xfb, 0xab, 0x8e,
            0xe9, 0xc6, 0x45, 0x8c, 0x4, 0xec, 0xc5, 0x99, 0xe7, 0x2b, 0x30, 0x13, 0xd1, 0xc6,
            0xcb, 0x85, 0x4d, 0x0, 0x0, 0x29, 0x2, 0x0, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0,
        ];

        println!("------------------------------------------");
        print_hex(packet.clone());
        let dns = Dns::new(&packet);

        let key: Vec<u8> = vec![
            0x3, 0x1, 0x0, 0x1, 0x9c, 0xa6, 0xe0, 0x70, 0x96, 0x89, 0x30, 0x0, 0x97, 0x63, 0x2f,
            0xd6, 0x2c, 0xe0, 0x4f, 0x29, 0xfd, 0xb0, 0xac, 0x20, 0x8b, 0x97, 0x81, 0xc6, 0x91,
            0xb6, 0xf5, 0xb5, 0x65, 0x79, 0xfa, 0xbf, 0xaf, 0xe4, 0xc6, 0xa, 0xd9, 0x94, 0x12,
            0x5b, 0xc5, 0xc8, 0x15, 0x87, 0x46, 0x3b, 0xdf, 0xf6, 0x60, 0x60, 0x94, 0x89, 0x53,
            0x5, 0x1b, 0x1e, 0xdb, 0x67, 0x6f, 0xcc, 0xd3, 0x88, 0xf9, 0xc6, 0x2b, 0x92, 0x30,
            0xfa, 0x2c, 0xe1, 0xee, 0xc4, 0xca, 0x1c, 0xfd, 0xde, 0x16, 0xb5, 0x75, 0x8a, 0x76,
            0xf8, 0x8d, 0x9a, 0xbb, 0x56, 0x17, 0x61, 0xa9, 0x8e, 0x60, 0xce, 0x23, 0xdf, 0x20,
            0x2d, 0xde, 0x1, 0x67, 0x45, 0x3f, 0x95, 0x8f, 0x38, 0xee, 0x62, 0x4f, 0xf4, 0xbc,
            0xa9, 0x14, 0x0, 0x59, 0x70, 0x49, 0xf7, 0xcc, 0xcd, 0xef, 0x71, 0xee, 0x4, 0x7b, 0x50,
            0x37, 0xba, 0x94, 0xa5, 0x15, 0xd, 0x93, 0x17, 0x22, 0x52, 0xf, 0xd1, 0xef, 0x32, 0x73,
            0xf8, 0x5e, 0x77, 0x85, 0x7b, 0x10, 0x71, 0x57, 0xde, 0x91, 0xa4, 0xb7, 0x32, 0xd8,
            0xef, 0xae, 0xd9, 0x6e, 0x82, 0x84, 0x88, 0x83, 0xa, 0x39, 0x6b, 0xa3, 0x3, 0xc2, 0x71,
            0x4d, 0xf3, 0x5d, 0xf5, 0xf1, 0xc9, 0x6c, 0xbf, 0x54, 0xa3, 0x3a, 0x4c, 0xe6, 0xbc,
            0x80, 0xd7, 0xfe, 0x68, 0xa6, 0x95, 0x91, 0xcb, 0xff, 0x78, 0x88, 0x79, 0x7a, 0xbf,
            0x2b, 0xae, 0xca, 0x80, 0x8b, 0xd2, 0x93, 0xf0, 0xee, 0x61, 0x9a, 0x1c, 0xd8, 0x2e,
            0x45, 0xe, 0x40, 0x45, 0xd5, 0x49, 0x13, 0x91, 0x57, 0x44, 0x4c, 0xb7, 0xd9, 0x77,
            0x25, 0x2c, 0x16, 0xc5, 0x3d, 0x4c, 0x79, 0xb1, 0x3, 0xbe, 0xd7, 0xc1, 0x6a, 0xd, 0xee,
            0xa3, 0xe9, 0x99, 0xc1, 0x64, 0x85, 0x96, 0x97, 0x3d, 0x92, 0xec, 0xf2, 0x58, 0x17,
            0x7b, 0xd8, 0x47,
        ];
        assert_eq!(dns.answer_count(), 3, "DNS long answer 1");
        assert_eq!(dns.question_count(), 1, "DNS long query 1");
        assert_eq!(dns.additional_count(), 1, "DNS long additional 1");
        assert_eq!(dns.answer_list[0].name, "<Root>", "DNS long additional 1");
        assert_eq!(
            dns.answer_list[0].dns_key.as_ref().unwrap().public_key,
            key,
            "DNS long additional 1"
        );

        // println!("DNS: {:?}", dns);
    }
}
